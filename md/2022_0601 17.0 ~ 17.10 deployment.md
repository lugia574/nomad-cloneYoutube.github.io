# 17 DEPLOYMENT

## 17.0 Building the Backend

이제 백엔드를 실제 서버로 배포할꺼임

그래서 Heroko 를 통해 배포할건데 이게 쉽지 않데

- 어떤 node.js 환경에서도 서버가 실행될 수 있게 설정을 바꿔야함

- DB 설정도 바꿔야함 우린 ㄹㅇ DB를 쓰지 않음

  ㄴ 쌉 인정 난 뭔 몽고디비를 쓰나했음 오라클이나 마이에스큐엘도 아니고 뭔 몽고디비여

- 그리고 파일들을 우리 서버가 아니라 아마존에 올려야함

우리의 코드를 호환성 있게 빌드하고 압축해야함

코드를 실행하려면

**nodemon을 사용해서 basbel-node를 실행함**

`nodemon.json`

```json
{
  "ignore": ["webpack.config.js", "src/client/*", "assets/*"],
  "exec": "babel-node src/init.js"
}
```

바벨노드는 실제로 서비스 되는 곳이 아니라 개발할때만 사용되는 목적임

왜냐면 바벨노드는 자바스크립트를 실행할 수 있게 도와줌

하지만 바벨노드를 사용하면 퍼포먼스 문제가 있음 (속도)

그래서 `init.js` 일반적인 js 코드로 바꿔야함

`Babel CLI` 를 사용할꺼임 babel cli 는 내가 원하는대로 코드를 바꿔줌

```
npm install --save-dev @babel/cli
```

scripts 도 만들자

`package.json`

```json
  "scripts": {
    "build:server": "babel src/init.js -d build",
    "dev:server": "nodemon",
    "dev:assets": "webpack"
  },
```

`-d` 는 directory 를 지정해준다는 소리임

내가 빌드한 코드를 어디에 저장할 것인지 말하는거임

```
npm run build:server
```

실행하면 build 란 폴더가 생김

안에 init.js도 코드 싹 옛날 코드로 바꿔줌

근데 init 만 됨 nodemon은 파일을 실행하고 그 파일 모든걸 실행함

babel의 경우 한 파일만 실행하는게 아닌, 모든 폴더를 빌드해서 실행해야함

```json
"build:server": "babel src -d build"
```

이렇게

만들어진 build 폴더를 지우고 다시 실행해보자

그럼 개같이 다 생김

.gitigonre에 빌드폴더를 적어 놀자

이유는 깃헙에 올린 필욘 없자나

```
/node_modules
.env
/uploads
/assets
/build
```

코드를 빌드할때 client 부분도 빌드가 됐는데

여긴 원하지 않음 여긴 백엔드 부분이 아니니까

webpack 하나만 가능함

이걸 이따가 고칠꺼임

이제 start 라는 새로운 명령어를 만들껀데

`bulid/init.js` 를 실행 할꺼임

nodemon은 `babel-node src/init.js`를 실행함

난 node build/init.js 를 실행할꺼임

이건 일반 js 코드니까 node는 babel 없이도 이해할 수 있음

`npm run start` 실행하면 에러 뜸

```
ReferenceError: regeneratorRuntime is not defined
```

regeneratorRuntime 이 정의되지 않았데

이 에러는 async, await 사용할때 뜨는 에러임

그리고 pug 파일들은 build가 안됨

이걸 복사해야함

## 17.1 Building the Backend part Two

`regeneratorRuntime` 는 async 와 await를 쓸 수 있게 해줌

이 문제를 client에서 본적이 있고 고쳐본 적도 있음

근데 왜 난 기억이 안날까 ㅋ

바로 `main.js` 에

```js
import "regenerator-runtime";
```

를 하면 됨

이걸 `init.js`에 똑같이 해주면 됨

이러거 다시 빌드 해주고

start 해주면 서버가 잘 실행이 된다~

이제 바벨의 도움 없이 node.js가 코드를 잘 이해하고 실행할 수 있게됨

들가면 잘 보여지지만 사실 제대로된게 아님

왜냐면 view 폴더가 build 폴더에 없거든

근데 왜 됨?

이유는 `server.js`

`build/server.js`

```js
app.set("views", process.cwd() + "/src/views");
```

view 폴더는 현재 working directorty(=cwd) 에서

working directorty는 node를 실행한 폴더위치를 말함

package.json 을 갖고 있는 폴더를 말하니까

잘 된거임

그래서 옮길 필요 없데

ㅋ

지금까지 백엔드 빌드였음

맞다 이 빌드서버는 환경변수 접근도 쌉가능임

```js
_mongoose["default"].connect(process.env.DB_URL, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
}); // db 연결
```

여기서 DB_URL 는 .env 에서 가져온거임

이제 클라이언트 코드를 빌드하고 좀더 프로페셔널하게 만들제

## 17.2 Building the Frontend

webpack에는 두가지 모드가 있음

development 와 production

production 모드가 훨씬 코드가 작음

그래서 asset을 production 모드로 빌드 할꺼임

먼저 `webpack.config.js` 에서

```js
  mode: "development",
```

를 지우고 명령어에 어떤 모드를 쓸껀지 설정함

`package.json`

```json
  "scripts": {
    "start": "node build/init.js",
    "build:server": "babel src -d build",
    "build:assets": "webpack --mode=  ",
    "dev:server": "nodemon",
    "dev:assets": "webpack --mode=development"
  },
```

build:assets 이나 dev:assets 이나 모두 잘 실행됨

build:assets 실행하고 가서 보면 1줄로 존나 압축해서 보여지고 있음

문제는 build:assets 했지만 여전히 watch 모드임

오직 dev:assets 일때만 watch 모드이여야함

그러니까 webpack.config.js에서 watch 모드를 지울꺼임

```js
  watch: true,
```

그리고 watch를 명령어에 추가할꺼임

`package.json`

```json
"dev:assets": "webpack --mode=development -w"
```

이렇게 하면 개발용이든 제품용이든 둘다 같은 webpack 사용 쌉가능

이제 Heroku 를 추가해보자

Heroku에 내부에 서버를 둘꺼임

그전에 build:server 랑 build:assets 을 묶어 놓자

```json
"build": "npm run build:server && npm run build:assets",
```

## 17.3 Deploying to Heroku
